<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Enemy_Move_Right</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//currently does not work for speeds less that one because of collisions
patrolSpeed = 1;
chasingSpeed = 2;
pausedDirectionChangeFactor = 50; //higher number = lower chance of direction change when paused (per frame)
patrolingPauseFactor = 1000; //higher number = lower chance of randomly pausing while patroling
peripheralVisionAngle = 5;
enemySpeed = patrolSpeed; 
lineOfSightToPlayer = false;

//collisoins with player
padLeft = 8
padRight = 8

patrolDirection = WAY.LEFT;
facingDirection = WAY.LEFT;
//distances to top and bottom of player
lineOfSightOffsetUp = 28;
lineOfSightOffsetDown = 32;

//enemy will pause when it loses sight of the player
minDistanceBeforeNextPause = 256;
distanceSinceLastPause = minDistanceBeforeNextPause;
maxPauseInSeconds = 4;
pauseActive = true;
movementActive = true;
timeToMovementActive = 0;  //keep track of how long the enemy has been paused
/*
    Moving toward the player due to line of sight is deactivated
    when the enemy touches a wall (and therefore must turn around)
    and is not in the line of sight of the player.
    This is reactivaed when the player is near horizonal with the enemy and in
    the line of sight, or when the enemy has moved toActiveLineOfSightSpace pixels
*/
toActiveLineOfSightMinSpace = 192;
toActiveLineOfSightMaxSpace = 320;
lineOfSightActive = true;
toActiveLineOfSightCounter = 0;
chasing = false; //true if chasing the player

// state of the enemy's position/physics
vspeed = 0;
grounded = false;
jumping = false;
climbing = false;
touchingLadder = false;
movingUpLadder = false;
ladderBelow = false;
magnetized = false;

currentDir = DIR.NORTH;

// wall transitions
degreesToRotate = 0;
deltaDegrees = 2;

// abilities
hasMagnetBoots = true;

// transitions
door_id = "";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// === COLLISION ===
    
    // "Floor" block collisions
    enemyCollision(self, WAY.LEFT, obj_Floor);
    enemyCollision(self, WAY.RIGHT, obj_Floor);
    stdCollision(self, WAY.ABOVE, obj_Floor);
    
    // Magnet block collisions
    //if(!magnetized) {
    enemyCollision(self, WAY.LEFT, obj_Magnet);
    enemyCollision(self, WAY.RIGHT, obj_Magnet);
    stdCollision(self, WAY.ABOVE, obj_Magnet);  
    //}
    
    // If we are not moving upward, check the bottom for a block
    if (vspeed &gt;= 0) {
        // determine which blocks we are colliding with
        floorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Floor);
        magFloorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Magnet);
        ladderBlockBelow = checkCollisionDir(currentDir, WAY.BELOW, obj_Ladder);
        restOfBody = collision_rectangle(bbox_left + 1, bbox_bottom - 2, bbox_right - 1, bbox_top, obj_Ladder, false, true);
        if((floorBlock || magFloorBlock) &amp;&amp; !movingUpLadder &amp;&amp; currentDir == DIR.NORTH) {
            if(floorBlock != noone) {
                // Move onto the floor and stop gravity
                vspeed = 0;
                y = floorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
            if(magFloorBlock != noone) {
                // Move onto the magnet block below and stop gravity
                vspeed = 0;
                y = magFloorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
        } else if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone) { //&amp;&amp; !climbing
            // stand on the top of ladders
            vspeed = 0;
            y = ladderBlockBelow.y - (sprite_height / 2);
            grounded = true;
        } else {
            grounded = false;
        }
        
        /*if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone) {
            ladderBelow = true;
        } else {
            ladderBelow = false;
        }*/
    }
    
    // Gravity
    if (!grounded) { //&amp;&amp; !climbing &amp;&amp; !magnetized
        vspeed += global.gravFactor;
        if (vspeed &gt; global.maxFallSpeed) {
            vspeed = global.maxFallSpeed;
        }
    } else {
        vspeed = 0;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var hadLineofSight = lineOfSightToPlayer and facingPlayer;
var x_0 = x;
lineOfSightToPlayer = false;
facingPlayer = false;
playerInPeripheralVisionCone = false; //does not account for if there is line of sight or not
cx = 0;
cy = 0;
lastDirection = 0;
if instance_exists(obj_Character) {
    //check if there is  a line of sight to the player
    cx = obj_Character.x;
    cy = obj_Character.y;
    var sightBlockedByFloor = collision_line(x, y-16, cx, cy + lineOfSightOffsetDown, obj_Floor, false, true) and collision_line(x, y-16, cx, cy - lineOfSightOffsetUp, obj_Floor, false, true);
    var sightBlockedByMagnet = collision_line(x, y-16, cx, cy + lineOfSightOffsetDown, obj_Magnet, false, true) and collision_line(x, y-16, cx, cy - lineOfSightOffsetUp, obj_Magnet, false, true);
    var sightBlockedBySideDoor = false;
    var i;
    for (i = 0; i &lt; instance_number(obj_SideDoor); i += 1) {
        var sideDoor = instance_find(obj_SideDoor, i);
        if not(sideDoor.is_on) { //if door is not open
            if collision_line(x, y-16, cx, cy + lineOfSightOffsetDown, obj_SideDoor, false, true) and collision_line(x, y-16, cx, cy - lineOfSightOffsetUp, obj_SideDoor, false, true) {
                //if there is a door that blocks line of sight
                sightBlockedBySideDoor = true;
            }
        }
    }
    //var playerOnLevel = collision_line(x, y, cx, y, obj_Character, false, true);
    lineOfSightToPlayer = not(sightBlockedByFloor or sightBlockedByMagnet or sightBlockedBySideDoor);// and playerOnLevel;
    facingPlayer = (facingDirection == WAY.LEFT and (x - cx &gt;= 0)) or (facingDirection == WAY.RIGHT and (x - cx &lt;= 0))
    playerInPeripheralVisionCone = abs(y - cy)*tan(degtorad(peripheralVisionAngle)) &gt;= abs(x - cx);
}

//activate line of sight chase if the player is near horizonal with the enemy
if (abs(cy - y) &lt; 60) {
    lineOfSightActive = true;
}
if (grounded) { //let's say the enemy cannot move left or right unless grounded for now
    if (lineOfSightToPlayer and lineOfSightActive and (facingPlayer or playerInPeripheralVisionCone)) { //conditions for chasing the player
        chasing = true;
        enemySpeed = chasingSpeed;
        x += enemySpeed*sign(cx - x);
        /*if ((cx - x) &gt; 0) {
            patrolDirection = WAY.RIGHT;
        } else {
            patrolDirection = WAY.LEFT;
        }*/
        randInt = irandom(1);
        if (randInt == 1) {
            patrolDirection = WAY.LEFT;
        } else {
            patrolDirection = WAY.RIGHT;
        }
    } else { //enemy does not see player
        //if just lost sight of the player
        if (hadLineofSight and lineOfSightActive) {
            //stop moving for some random amount of time
            //if enemy has just lost sight of the player
            if (movementActive and pauseActive) {
                movementActive = false;
                pauseActive = false;
                distanceSinceLastPause = 0;
                timeToMovementActive = irandom(room_speed*maxPauseInSeconds);
            }
        }
        
        if (movementActive) { //patroling
            enemySpeed = patrolSpeed;
            chasing = false;
            if (patrolDirection == WAY.LEFT) {
                x -= enemySpeed;
            } else {
                x += enemySpeed;
            }
            //randomly pause sometimes 
            if (irandom(patrolingPauseFactor) == 0) {
                movementActive = false;
                pauseActive = false;
                distanceSinceLastPause = 0;
                timeToMovementActive = irandom(room_speed*maxPauseInSeconds);
            }
        } else { //paused
            timeToMovementActive--;
            if (timeToMovementActive &lt;= 0) { 
                movementActive = true;
            }
            //randomly change direction if paused
            if (irandom(pausedDirectionChangeFactor) == 0) {
                if (facingDirection == WAY.LEFT) {
                    facingDirection = WAY.RIGHT;
                    patrolDirection = WAY.RIGHT;
                } else {
                    facingDirection = WAY.LEFT;
                    patrolDirection = WAY.LEFT;
                }
            }
        }
    }
    updateLineOfSightStatus(abs(x-x_0));
    //update sprite
    if (x == x_0) { //did not move
        if (facingDirection == WAY.LEFT) {
            sprite_index = spr_Enemy_Stand_Left;
        } else {
            sprite_index = spr_Enemy_Stand_Right;
        }
    } else { //moved
        if (x &lt; x_0) {
            facingDirection = WAY.LEFT;
            sprite_index = spr_Enemy_Move_Left;
        } else {
            facingDirection = WAY.RIGHT;
            sprite_index = spr_Enemy_Move_Right;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_Laser">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if other.is_on {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_Character">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if collision_rectangle(bbox_left + padLeft, bbox_top, bbox_right - padRight, bbox_bottom, obj_Character, true, true) {
    room_restart();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>500</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring>draw_self();</codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//this is all debug output and should be removed before final version
if(lineOfSightToPlayer) {
    draw_set_color(c_lime);
}
draw_line(x, y-16, cx, cy + lineOfSightOffsetDown);
draw_line(x, y-16, cx, cy - lineOfSightOffsetUp);
draw_set_color(c_green);
draw_rectangle(bbox_left + padLeft, bbox_top, bbox_right - padRight, bbox_bottom, true);
draw_text(x - 20, y - 20, chasing);
draw_text(x, y - 45, timeToMovementActive);
if not(playerInPeripheralVisionCone) {
    draw_set_color(c_blue);
} else {
    draw_set_color(c_red);
}
draw_line(x, y, x+tan(degtorad(peripheralVisionAngle/2))*100, y+200);
draw_line(x, y, x+tan(degtorad(peripheralVisionAngle/2))*100, y-200);
draw_line(x, y, x-tan(degtorad(peripheralVisionAngle/2))*100, y+200);
draw_line(x, y, x-tan(degtorad(peripheralVisionAngle/2))*100, y-200);
draw_set_color(c_green);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
