<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Enemy1</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This code is borrowed straight from the player
//as such much of it is probably unnecessary

controlsEnabled = false;
//currently does not work for speeds less that one because of collisions
enemySpeed = 1; 
patrolDirection = WAY.LEFT;
lineOfSightOffsetUp = 28;
lineOfSightOffsetDown = 32;
/*
    Moving toward the player due to line of sight is deactivated
    when the enemy touches a wall (and therefore must turn around)
    and is not in the line of sight of the player.
    This is reactivaed when the player is near horizonal with the enemy and in
    the line of sight, or when the enemy has moved toActiveLineOfSightSpace pixels
*/
toActiveLineOfSightSpace = 256;
lineOfSightActive = true;
toActiveLineOfSightCounter = 0;
chasing = false; //true if chasing the player

// state of the player's position/physics
vspeed = 0;
grounded = false;
jumping = false;
climbing = false;
touchingLadder = false;
movingUpLadder = false;
ladderBelow = false;
magnetized = false;

currentDir = DIR.NORTH;

// wall transitions
degreesToRotate = 0;
deltaDegrees = 2;

// abilities
hasMagnetBoots = true;

// transitions
door_id = "";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// === COLLISION ===
if(controlsEnabled) {    
    /* //Check if colliding with a ladder
    ladderBlock = checkCollisionDir(currentDir, WAY.SELF, obj_Ladder);
    if (ladderBlock != noone) {
        touchingLadder = true;
    } else {
        touchingLadder = false;
        movingUpLadder = false;
        climbing = false;
    }
    */
    
    // "Floor" block collisions
    enemyCollision(self, WAY.LEFT, obj_Floor);
    enemyCollision(self, WAY.RIGHT, obj_Floor);
    stdCollision(self, WAY.ABOVE, obj_Floor);
    
    // Magnet block collisions
    if(!magnetized) {
        stdCollision(self, WAY.LEFT, obj_Magnet);
        stdCollision(self, WAY.RIGHT, obj_Magnet);
        stdCollision(self, WAY.ABOVE, obj_Magnet);  
    }
    
    // If we are not moving upward, check the bottom for a block
    if (vspeed &gt;= 0) {
        // determine which blocks we are colliding with
        floorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Floor);
        magFloorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Magnet);
        ladderBlockBelow = checkCollisionDir(currentDir, WAY.BELOW, obj_Ladder);
        restOfBody = collision_rectangle(bbox_left + 1, bbox_bottom - 2, bbox_right - 1, bbox_top, obj_Ladder, false, true);
        if((floorBlock || magFloorBlock) &amp;&amp; !movingUpLadder &amp;&amp; currentDir == DIR.NORTH) {
            if(floorBlock != noone) {
                // Move onto the floor and stop gravity
                vspeed = 0;
                y = floorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
            if(magFloorBlock != noone) {
                // Move onto the magnet block below and stop gravity
                vspeed = 0;
                y = magFloorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
        } else if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone &amp;&amp; !climbing) {
            // stand on the top of ladders
            vspeed = 0;
            y = ladderBlockBelow.y - (sprite_height / 2);
            grounded = true;
        } else {
            grounded = false;
        }
        
        if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone) {
            ladderBelow = true;
        } else {
            ladderBelow = false;
        }
    }
    
    // Gravity
    if (!grounded &amp;&amp; !climbing &amp;&amp; !magnetized) {
        vspeed += global.gravFactor;
        if (vspeed &gt; global.maxFallSpeed) {
            vspeed = global.maxFallSpeed;
        }
    } else {
        vspeed = 0;
    }
    
    // determine if the player is on a magnet block
    magnetBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Magnet);
    magnetized = magnetBlock != noone;
    // instant flip to NORTH when falling off ceilings, etc.
    if(!magnetized &amp;&amp; currentDir != DIR.NORTH) {
        image_angle = 0;
        view_angle = 0;
        currentDir = DIR.NORTH;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>lineOfSightToPlayer = false;
cx = 0;
cy = 0;
lastDirection = 0;
if instance_exists(obj_Character) {
    //check if there is  a line of sight to the player
    cx = obj_Character.x;
    cy = obj_Character.y;
    var sightBlockedByFloor = collision_line(x, y-16, cx, cy + lineOfSightOffsetDown, obj_Floor, false, true) and collision_line(x, y-16, cx, cy - lineOfSightOffsetUp, obj_Floor, false, true);
    var sightBlockedByMagnet = collision_line(x, y, cx, y, obj_Magnet, false, true);
    var playerOnLevel = collision_line(x, y, cx, y, obj_Character, false, true);
    lineOfSightToPlayer = not(sightBlockedByFloor or sightBlockedByMagnet);// and playerOnLevel;
}
//activate line of sight chase if the player is near horizonal with the enemy
if (abs(cy - y) &lt; 60) {
    lineOfSightActive = true;
}
if (grounded) { //let's say the enemy cannot move left or right unless grounded for now
    if (lineOfSightToPlayer and lineOfSightActive) {
        chasing = true;
        enemySpeed = 2;
        x += enemySpeed*sign(cx - x);
        if ((cx - x) &gt; 0) {
            patrolDirection = WAY.RIGHT;
        } else {
            patrolDirection = WAY.LEFT;
        }
    } else {
        enemySpeed = 1;
        chasing = false;
        if (patrolDirection == WAY.LEFT) {
            x -= enemySpeed;
        } else {
            x += enemySpeed;
        }
    }
    updateLineOfSightStatus(enemySpeed);
}

// Handle transitioning on right angles (eg. floor to wall, wall to ceiling)
if(degreesToRotate != 0) {
    if(degreesToRotate &gt; 0) {
        // rotate CCW
        image_angle += deltaDegrees;
        view_angle -= deltaDegrees;
        degreesToRotate -= deltaDegrees;
        // move the player slightly each frame to prevent them from ending
        // up in a magnet block after the rotation is complete
        switch(currentDir) {
        case DIR.NORTH:
            x -= 16/45;
            y += 16/45;
            break;
        case DIR.WEST:
            x += 16/45;
            y += 16/45;
            break;
        case DIR.SOUTH:
            x += 16/45;
            y -= 16/45;
            break;
        case DIR.EAST:
            x -= 16/45;
            y -= 16/45;
            break;
        }
    } else {
        // rotate CW
        image_angle -= deltaDegrees;
        view_angle += deltaDegrees;
        degreesToRotate += deltaDegrees;
        switch(currentDir) {
        case DIR.NORTH:
            x += 16/45;
            y += 16/45;
            break;
        case DIR.WEST:
            x += 16/45;
            y -= 16/45;
            break;
        case DIR.SOUTH:
            x -= 16/45;
            y -= 16/45;
            break;
        case DIR.EAST:
            x -= 16/45;
            y += 16/45;
            break;
        }
    }
} else if(!controlsEnabled) {
    // the rotation has completed
    controlsEnabled = true;
    
    // image angle should be from 0-359
    while(image_angle &lt; 0) {
        image_angle += 360;
    }
    while(image_angle &gt;= 360) {
        image_angle -= 360;
    }
    // set the new direction based on the image rotation
    switch(image_angle) {
    case 0:
        currentDir = DIR.NORTH;
        break;
    case 90:
        currentDir = DIR.WEST;
        break;
    case 180:
        currentDir = DIR.SOUTH;
        break;
    case 270:
        currentDir = DIR.EAST;
        break;
    }
         
    // Now that the rotation is complete, do a final correction
    magnetBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Magnet);
    if(magnetBlock != noone) {
        switch(currentDir) {
            case DIR.NORTH:
                y = magnetBlock.y - (sprite_height / 2);
                break;
            case DIR.EAST:
                x = magnetBlock.x + magnetBlock.sprite_width + (sprite_height / 2);
                break;
            case DIR.SOUTH:
                y = magnetBlock.y + magnetBlock.sprite_height + (sprite_height / 2);
                break;
            case DIR.WEST:
                x = magnetBlock.x - (sprite_height / 2);
                break;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_Character">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_line(x, y-16, cx, cy + lineOfSightOffsetDown);
draw_line(x, y-16, cx, cy - lineOfSightOffsetUp);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>500</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring>draw_self();</codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
