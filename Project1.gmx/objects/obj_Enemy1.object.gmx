<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Enemy_Move_Right</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//=== tunable parameters ===
//(these are default paramaters, behavior of an individual enemy can be changed in it's instance creation code)
//currently does not work for speeds less that one because of collisions
patrolSpeed = 1;
patrolImageSpeed = 0.025; //animation speed while patroling (chasing speed is calculated based on this)
chasingSpeed = 2;
//set a probability factor to -1 for zero probability
pausedDirectionChangeFactor = 50; //higher number = lower chance of direction change when paused (per frame)
patrolingPauseFactor = 1000; //higher number = lower chance of randomly pausing while patroling
peripheralVisionAngle = 5; //vision cones above and below enemy, allows a small amount of vision behind the enemy
//enemy will pause when it loses sight of the player
minDistanceBeforeNextPause = 256;
maxPauseInSeconds = 4;
//collisoins with player, decreasing the size of the enemy hit box
padLeft = 8
padRight = 8
/*
    Moving toward the player due to line of sight is deactivated
    when the enemy touches a wall (and therefore must turn around)
    and is not in the line of sight of the player.
    This is reactivaed when the player is near horizonal with the enemy and in
    the line of sight, or when the enemy has moved toActiveLineOfSightSpace pixels

    Setting these values to zero effectivly disables this mechanic.
    Updates to the AI have made it uncessary, as it was originally designed to
    prevet jittery motion from moving in and out of the line of sight of a player near
    a boundry.  The mechanic can still be activated by chaging these values if desired.
*/
toActiveLineOfSightMinSpace = 0; //192;
toActiveLineOfSightMaxSpace = 0; //320;
//distances from center of player that enemy can see when calculating line of sight
lineOfSightOffset = 30;
//starting condidions
facingDirection = WAY.LEFT;
//========================

//set necessary inital conditions
patrolDirection = facingDirection;
enemySpeed = patrolSpeed; 
lineOfSightToPlayer = false;

distanceSinceLastPause = minDistanceBeforeNextPause;
pauseActive = true;
movementActive = true;
timeToMovementActive = 0;  //keep track of how long the enemy has been paused
lineOfSightActive = true;
toActiveLineOfSightCounter = 0;
chasing = false; //true if chasing the player

// state of the enemy's position/physics
vspeed = 0;
grounded = false;
jumping = false;
climbing = false;
touchingLadder = false;
movingUpLadder = false;
ladderBelow = false;
magnetized = false;

currentDir = DIR.NORTH;

// wall transitions
degreesToRotate = 0;
deltaDegrees = 2;

// abilities
hasMagnetBoots = true;

// transitions
door_id = "";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// === COLLISION ===
    
    // "Floor" block collisions
    enemyCollision(self, WAY.LEFT, obj_Floor);
    enemyCollision(self, WAY.RIGHT, obj_Floor);
    stdCollision(self, WAY.ABOVE, obj_Floor);
    
    // Magnet block collisions
    //if(!magnetized) {
    enemyCollision(self, WAY.LEFT, obj_Magnet);
    enemyCollision(self, WAY.RIGHT, obj_Magnet);
    stdCollision(self, WAY.ABOVE, obj_Magnet);  
    //}
    
    // Side doors collisions
    enemyCollisionDoor(self, WAY.LEFT, obj_SideDoor);
    enemyCollisionDoor(self, WAY.RIGHT, obj_SideDoor);
    
    // If we are not moving upward, check the bottom for a block
    if (vspeed &gt;= 0) {
        // determine which blocks we are colliding with
        floorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Floor);
        magFloorBlock = checkCollisionDir(currentDir, WAY.BELOW, obj_Magnet);
        ladderBlockBelow = checkCollisionDir(currentDir, WAY.BELOW, obj_Ladder);
        restOfBody = collision_rectangle(bbox_left + 1, bbox_bottom - 2, bbox_right - 1, bbox_top, obj_Ladder, false, true);
        if((floorBlock || magFloorBlock) &amp;&amp; !movingUpLadder &amp;&amp; currentDir == DIR.NORTH) {
            if(floorBlock != noone) {
                // Move onto the floor and stop gravity
                vspeed = 0;
                y = floorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
            if(magFloorBlock != noone) {
                // Move onto the magnet block below and stop gravity
                vspeed = 0;
                y = magFloorBlock.y - (sprite_height / 2);
                grounded = true;
                climbing = false;
            }
        } else if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone) { //&amp;&amp; !climbing
            // stand on the top of ladders
            vspeed = 0;
            y = ladderBlockBelow.y - (sprite_height / 2);
            grounded = true;
        } else {
            grounded = false;
        }
        
        /*if (ladderBlockBelow != noone &amp;&amp; restOfBody == noone) {
            ladderBelow = true;
        } else {
            ladderBelow = false;
        }*/
    }
    
    // Gravity
    if (!grounded) { //&amp;&amp; !climbing &amp;&amp; !magnetized
        vspeed += global.gravFactor;
        if (vspeed &gt; global.maxFallSpeed) {
            vspeed = global.maxFallSpeed;
        }
    } else {
        vspeed = 0;
    }
    
    //update sprite
    if (x == x_0) { //did not move
        if (facingDirection == WAY.LEFT) {
            sprite_index = spr_Enemy_Stand_Left;
        } else {
            sprite_index = spr_Enemy_Stand_Right;
        }
    } else { //moved
        if chasing {
            image_speed = patrolImageSpeed * (chasingSpeed / patrolSpeed);
        } else {
            image_speed = patrolImageSpeed;
        }
        if (x &lt; x_0) {
            facingDirection = WAY.LEFT;
            sprite_index = spr_Enemy_Move_Left;
        } else {
            facingDirection = WAY.RIGHT;
            sprite_index = spr_Enemy_Move_Right;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var hadLineofSight = lineOfSightToPlayer and facingPlayer;
x_0 = x;
lineOfSightToPlayer = false;
facingPlayer = false;
playerInPeripheralVisionCone = false; //does not account for if there is line of sight or not
cx = 0;
cy = 0;
lastDirection = 0;
if instance_exists(obj_Character) {
    //check if there is  a line of sight to the player
    cx = obj_Character.x;
    cy = obj_Character.y;
    playerDirection = obj_Character.currentDir;
    lineOfSightToPlayer = lineOfSightToPlayerFunction();//not(sightBlockedByFloor or sightBlockedByMagnet or sightBlockedBySideDoor);// and playerOnLevel;
    facingPlayer = (facingDirection == WAY.LEFT and (x - cx &gt;= 0)) or (facingDirection == WAY.RIGHT and (x - cx &lt;= 0))
    playerInPeripheralVisionCone = abs(y - cy)*tan(degtorad(peripheralVisionAngle)) &gt;= abs(x - cx);
}

//activate line of sight chase if the player is near horizonal with the enemy
if (abs(cy - y) &lt; 60) {
    lineOfSightActive = true;
}
if (grounded) { //let's say the enemy cannot move left or right unless grounded for now
    if (lineOfSightToPlayer and lineOfSightActive and (facingPlayer or playerInPeripheralVisionCone)) { //conditions for chasing the player
        chasing = true;
        enemySpeed = chasingSpeed;
        //if chasing speed would move past the player's x coordinate (or to the player's x coordiante)
        //then just snap to the player's x coordiante
        if (sign(x-cx) != sign(x + enemySpeed*sign(cx - x) - cx)) {
            x = cx;
        } else {
            x += enemySpeed*sign(cx - x);
        }

        //move back (net no movement) if that move would have been out of line of sight of the player
        if not(lineOfSightToPlayerFunction()) {
            x = x_0;
        }
    } else { //enemy does not see player
        //if just lost sight of the player
        if (hadLineofSight and lineOfSightActive) {
            //stop moving for some random amount of time
            //if enemy has just lost sight of the player
            if (movementActive and pauseActive) {
                movementActive = false;
                pauseActive = false;
                distanceSinceLastPause = 0;
                timeToMovementActive = irandom(room_speed*maxPauseInSeconds);
            }
        }
        
        if (movementActive) { //patroling
            enemySpeed = patrolSpeed;
            chasing = false;
            if (patrolDirection == WAY.LEFT) {
                x -= enemySpeed;
            } else {
                x += enemySpeed;
            }
            //randomly pause sometimes 
            if (irandom(patrolingPauseFactor) == 0) {
                movementActive = false;
                pauseActive = false;
                distanceSinceLastPause = 0;
                timeToMovementActive = irandom(room_speed*maxPauseInSeconds);
            }
        } else { //paused
            timeToMovementActive--;
            if (timeToMovementActive &lt;= 0) { 
                movementActive = true;
            }
            //randomly change direction if paused
            if (irandom(pausedDirectionChangeFactor) == 0) {
                if (facingDirection == WAY.LEFT) {
                    facingDirection = WAY.RIGHT;
                    patrolDirection = WAY.RIGHT;
                } else {
                    facingDirection = WAY.LEFT;
                    patrolDirection = WAY.LEFT;
                }
            }
        }
    }
    updateLineOfSightStatus(abs(x-x_0)); //also updates pausing status
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_Laser">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if other.is_on {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_Character">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if collision_rectangle(bbox_left + padLeft, bbox_top, bbox_right - padRight, bbox_bottom, obj_Character, true, true) {
    room_restart();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>500</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring>draw_self();</codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//this is all debug output and should be removed before final version
//line of sight lines
if(lineOfSightToPlayer) {
    draw_set_color(c_lime);
}
draw_line(x, y-16, cx + xLineOfSightOffset, cy + yLineOfSightOffset);
draw_line(x, y-16, cx - xLineOfSightOffset, cy - yLineOfSightOffset);
draw_set_color(c_green);
//enemy modifyed hit box
draw_rectangle(bbox_left + padLeft, bbox_top, bbox_right - padRight, bbox_bottom, true);
//peripheral vision cone
if not(playerInPeripheralVisionCone) {
    draw_set_color(c_blue);
} else {
    draw_set_color(c_red);
}
draw_line(x, y, x+tan(degtorad(peripheralVisionAngle/2))*100, y+200);
draw_line(x, y, x+tan(degtorad(peripheralVisionAngle/2))*100, y-200);
draw_line(x, y, x-tan(degtorad(peripheralVisionAngle/2))*100, y+200);
draw_line(x, y, x-tan(degtorad(peripheralVisionAngle/2))*100, y-200);
draw_set_color(c_green);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
